local Resource(name, spec, apiVersion="v1") = {
  kind: name,
  apiVersion: apiVersion
} + spec;

local sleepD = (function(deploymentSpec) deploymentSpec + {
  terminationGracePeriodSeconds: 0
});

local sleep = (function(container) container + {
  command: [ "sleep" ],
  args: [ "infinity" ],
});
# todo add spec strategy recreate
local Deployment(name, spec) = {
  "apiVersion": "apps/v1",
  "kind": "Deployment",
  "metadata": {
    "name": name,
    "labels": {
      "app.kubernetes.io/name": name,
    }
  },
  "spec": {
    "selector": {
      "matchLabels": {
        "app.kubernetes.io/name": name,
      }
    },
    "template": {
      "metadata": {
        "labels": {
          "app.kubernetes.io/name": name,
        }
      },
      "spec": spec + {
        nodeSelector: {
          "cloud.google.com/gke-spot": "true",
          //"cloud.google.com/compute-class": "Performance",
          //"cloud.google.com/machine-family": "c3"
        },
        //terminationGracePeriodSeconds: 25
      }
    }
  }
};


{
  Deployment: Deployment,
  Container: (function(name, container) container + {
    name: name,
    resources: {
      requests: {
        memory: "10Mi",
        cpu: "10m",
      },
      /*
      limits: {
        memory: "30Mi",
        cpu: "30m",
      }*/
    }
  }),
  Service: (function(name) {
    "apiVersion": "v1",
    "kind": "Service",
    metadata: { name: name },
    "spec": {
      "selector": {
        "app.kubernetes.io/name": name,
      },
      "ports": [
        {
          "port": 80,
          "targetPort": "http"
        }
      ]
    }
  }),
  NetworkPolicy: (function(name) Resource("NetworkPolicy", {
    metadata: { name: name },
    "spec": {
      "podSelector": {
        "matchLabels": {
          "app.kubernetes.io/name": name,
        }
      },
      "policyTypes": [
        "Ingress"
      ],
      "ingress": [
        {
          "from": [
            {
              "podSelector": {
                "matchLabels": {
                  "app.kubernetes.io/name": "caddy"
                }
              }
            }
          ]
        }
      ]
    }
  }, apiVersion="networking.k8s.io/v1")),
  Secret: (function(name, data) Resource("Secret", {
    metadata: { name: name },
    data: { [key]: std.base64(data[key]) for key in std.objectFields(data) },
    immutable: true
  })),
  List: (function(list) Resource("List", {
    items: list
  })),
  Namespace: (function(name) Resource("Namespace", {
      metadata: {
        name: name,
        labels: {
          name: name
        }
      }
  })),
  ConfigMap: (function(name, data) Resource('ConfigMap', {
    data: data,
    immutable: true,
    metadata: {
      name: name
    }
  })),
  PersistentVolumeClaim: (function(name, capacity) Resource('PersistentVolumeClaim', {
    metadata: {
      name: name,
    },
    spec: {
      storageClassName: 'standard-rwo',
      # only used if binding to an existing volume
      #volumeName: name,
      # todo this is a bug waiting to happen
      # if a pod is on the same node? find
      # if its on a diff node? wont be scheduled...
      accessModes: [ 'ReadWriteOnce' ],
      resources: {
        requests: {
          storage: capacity,
        }
      },
    },
  })),
  PodDisruptionBudget: (function(name) Resource('PodDisruptionBudget', {
    metadata: {
      name: name
    },
    spec: {
      minAvailable: 1,
      selector: {
        matchLabels: {
          'app.kubernetes.io/name': name
        }
      }
    }
  }, apiVersion='policy/v1')),
}
